#!/bin/bash
# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ ~/bash_cmd -- Function to store and run commands from file                 ║
# ║ https://github.com/nicedreams/bash_cmd                                     ║
# ║ -------------------------------------------------------------------------- ║
# ║ Usage:                                                                     ║
# ║   Source this file inside your ~/.bashrc                                   ║
# ║   Or use as command (~/bin/cmd), but some options (like -fa) won't work.   ║
# ║    - Un-comment last line to use as script instead of function.            ║
# ║ -------------------------------------------------------------------------- ║
# ║ This program is free software: you can redistribute it and/or modify       ║
# ║ it under the terms of the GNU General Public License as published by       ║
# ║ the Free Software Foundation, either version 3 of the License, or          ║
# ║ (at your option) any later version.                                        ║
# ║                                                                            ║
# ║ This program is distributed in the hope that it will be useful,            ║
# ║ but WITHOUT ANY WARRANTY; without even the implied warranty of             ║
# ║ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              ║
# ║ GNU General Public License for more details.                               ║
# ║                                                                            ║
# ║ You should have received a copy of the GNU General Public License          ║
# ║ along with this program.  If not, see <https://www.gnu.org/licenses/>.     ║
# ╚════════════════════════════════════════════════════════════════════════════╝
# Version 2021-04-30

# Set CMDFILE variable if not already set from environment
if [[ ! "${CMDFILE}" ]]; then export CMDFILE="${HOME}/.cmdnotes"; fi

# Help/Usage message
usage() {
  printf "Store and run commands from file:\n\n"
  printf "Usage:\n"
  printf "  cmd <option>\t\t:Use default file as source\n"
  printf "  cmd <file> <option>\t:Use another file as source\n\n"
  printf "  cmd\t\t\t:displays stored commands by number\n"
  printf "    ##\t\t\t:run line number as command\n"
  printf "    -f |--fzf\t\t:run line as command or copy to clipboard (fzf/xclip)\n"
  printf "    -fa|--fzf-add\t:add line from history to cmd file (fzf)\n"
  printf "    -fd|--fzf-delete\t:delete line from cmd file (fzf)\n"
  printf "    -n |--numbers\t:displays stored commands by number\n"
  printf "    -c |--copy\t\t:copy line number to clipboard (xclip)\n"
  printf "    -l |--last\t\t:add last command retaining double/single quotes\n"
  printf "    -a |--alias #\t:create named bash alias from cmd number\n"
  printf "    -as|--alias-save #\t:save named bash alias in ~/.bash_aliases\n"
  printf "    -d |--delete #\t:delete command by line number\n"
  printf "    -e |--edit\t\t:edit cmd file\n"
  printf "    -b |--backup\t:backup cmd file with timestamp\n"
  printf "    -dd\t\t\t:delete blank lines and trailing spaces from cmd file\n"
  printf "    --clear\t\t:clear cmd file contents\n"
  printf "    -h |--help\t\t:this usage\n\n"
  printf "Default: [${CMDFILE}]\n"
  printf " Source: [${cmdfile}]\n\n"
}

# Run line number in file as command
run_command() {
  line=$(sed -n "${case_option}"p "${cmdfile}")
  #eval "${line}"
  bash -c "${line}"
}

# Display each line listing by number
number_file_loop() {
  local number=0
  while IFS='' read -r LINE || [ -n "${LINE}" ]; do
    ((number++))
    printf '%+3s %s\n' "${number}": "${LINE}"
  done < "${cmdfile}"
}

# Copy line number to clipboard (xclip)
option_copy() {
  if [[ "${cmd_option}" ]]; then
    line=$(sed -n "${cmd_option}"p "${cmdfile}")
    printf '%s' "${line}" | xclip -selection clipboard | printf '%s\n' && printf '%s\n' "Line ${cmd_option} copied to clipboard (xclip)" || printf '%s\n' "Issue when copying to clipboard (xclip)"
  else
    printf '%s\n' "Nothing entered to copy"
  fi
}

# Display commands in file via fzf
option_fzf() {
  if [[ ! $(command -v fzf) ]]; then
    printf "Fzf not found and required for this option!"
  else
    runcmd=$(fzf \
      --header="<enter> Run line as command | <ctrl-y> Xclip line to clipboard" \
      --bind="ctrl-y:execute-silent(printf '%s' "{+}" | xclip -selection clipboard | printf '%s\n')+abort" \
      ${fzf_options} < "${cmdfile}")
    #eval "${runcmd}"
    bash -c "${runcmd}"
  fi
}

# Add command from history to file via fzf
option_fzf_add() {
  if [[ ! $(command -v fzf) ]]; then
    printf "Fzf not found and required for this option!"
  else
    local histcmd=$(fc -l -n 1 | tail -n1000 | sed 's/^\s*//' | fzf --header="<enter> Add line from history to cmd" ${fzf_options})
  fi
  if [[ "${histcmd}" ]]; then printf '%s\n' "${histcmd}" >> "${cmdfile}"; fi
}

# Delete command line in file via fzf
option_fzf_delete() {
  fzfline=( $(cat -n "${cmdfile}" | sed -e 's/^[ \t]*//' | fzf --header="<enter> Delete selected line" ${fzf_options}) )
  if [[ "${fzfline}" ]]; then sed -i "${fzfline[0]}"d "${cmdfile}" && printf '%s\n' "Removed line: ${fzfline[0]} from: ${cmdfile}" || printf '%s\n' "Issue removing line: ${fzfline[0]} from: ${cmdfile}"; fi
}

# Add command line number as bash alias prompting for name for current session
option_alias() {
  if [[ ! "${cmd_option}" ]]; then printf '%s\n' "No line number entered"; return; fi
  read -p "Enter name of alias to create: " alias_name
  if [[ ! "${alias_name}" ]]; then
    printf '%s\n' "No name entered"
  else
    getcmd=$(sed -n ${cmd_option}p "${cmdfile}")
    alias "${alias_name}"="${getcmd}"
  fi
}

# Add command line number to ~/.bash_aliases prompting for name
option_alias_save() {
  if [[ ! "${cmd_option}" ]]; then printf '%s\n' "No line number entered"; return; fi
  read -p "Enter name of alias to append to ~/.bash_aliases: " alias_name
  if [[ ! "${alias_name}" ]]; then
    printf '%s\n' "No name entered"
  else
    getcmd=$(sed -n ${cmd_option}p "${cmdfile}")
    printf '%s\n' "alias ${alias_name}='${getcmd}'" >> "${HOME}"/.bash_aliases
  fi
}

# Add/Append last command ran to file
option_last() {
  lastcmd=$(fc -ln | tail -2 | head -1)
  printf '%s\n' "${lastcmd#"${lastcmd%%[![:space:]]*}"}" >> "${cmdfile}" && printf '%s\n' "Added last command to ${cmdfile##*/}" || printf '%s\n' "An error happened!"
}

# Delete command by line number from file
option_delete() {
  if [[ -z "${cmd_option}" ]]; then
    printf "No input entered\n"
  else
    sed -i "${cmd_option}"d "${cmdfile}" && printf "%sRemoved line ${cmd_option} from ${cmdfile##*/}\n" || printf "%sIssue removing line ${cmd_option} from ${cmdfile##*/}\n"
  fi
}

# Remove all double and trailing spaces in file
option_delete_double() {
  #sed '$!N; /^\(.*\)\n\1$/!P; D' "${cmdfile}"
  sed -i '/^ *$/d' "${cmdfile}" || printf '%s\n' "Issue removing blank lines with sed"
  sed -i 's/[ \t]*$//' "${cmdfile}" || printf '%s\n' "Issue removing trailing spaces with sed"
  printf '%s\n' "Deleted blank lines and trailing spaces from ${cmdfile##*/}"
}

# Backup command file using date-time stamp
option_backup() {
  local date_time="$(printf '%(%Y-%m-%d_%H.%M.%S)T' -1)"
  cp "${cmdfile}" "${cmdfile}"-"${date_time}" && printf "%sCreated backup of ${cmdfile##*/} to ${cmdfile}-${date_time}\n" || printf "%sIssue creating backup copy\n"
}

# Clear entire contents of file
option_clear() {
  read -r -p "Press Enter to clear/delete ${cmdfile##*/} or CTRL+C to cancel: "
  > "${cmdfile}" && printf '%s\n' "Cleared ${cmdfile}"
}

# ------------------------------------------------------------------
# Main function
cmd() {
  if [[ ! -e "${CMDFILE}" ]]; then touch "${CMDFILE}"; fi

  fzf_options="--height 50% --reverse --exact --preview-window=hidden --multi=0"

  # Set variables based on if using file or not
  if [[ -f "$1" ]]; then
    local cmdfile="$1"
    local case_option="$2"
    local cmd_option="$3"
  else
    local cmdfile="$CMDFILE"
    local case_option="$1"
    local cmd_option="$2"
  fi

  # Main command options
  case "${case_option}" in
    [1-9]*) run_command ;;
    -c|--copy) option_copy ;;
    -f|--fzf) option_fzf ;;
    -fa|--fzf-add) option_fzf_add ;;
    -fd|--fzf-delete) option_fzf_delete ;;
    -n|--number|--numbers) number_file_loop ;;
    -a|--alias) option_alias ;;
    -as|--alias-save) option_alias_save ;;
    -l|--last) option_last ;;
    -d|--delete|-rm) option_delete ;;
    -dd|--delete-double) option_delete_double ;;
    -b|--backup) option_backup ;;
    --clear) option_clear ;;
    -e|--edit) "${EDITOR}" "${cmdfile}" ;;
    -h|--help) usage ;;
    *)
    if [[ ! "${case_option}" ]]; then
      # List commands in file by line number
      number_file_loop
    else
      # Option not found message
      printf '%s\n' "${case_option}: not a valid option (--help for usage)"
    fi
    ;;
  esac
}

# Un-comment this line below if using as script in ~/bin/ or somewhere else
#cmd "$@"
